
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>demo - shader</title>
		<meta charset="utf-8">
		<style>
			body {
			  margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>

    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/dat.gui.min.js"></script>
		
    <script id="vertexShader" type="x-shader/x-vertex">
      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 projectionMatrix;

     	attribute vec3 position;
	    attribute vec3 normal;

      uniform float in_val; //a value that changes slowly over time...
	    uniform float displaceAmt; //controls the amount of vertex displacement...
	
      varying float noiseVal, noiseVal2;


      vec3 mod289(vec3 x)
      {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec4 mod289(vec4 x)
      {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec4 permute(vec4 x)
      {
        return mod289(((x*34.0)+1.0)*x);
      }

      vec4 taylorInvSqrt(vec4 r)
      {
        return 1.79284291400159 - 0.85373472095314 * r;
      }

      vec3 fade(vec3 t) {
        return t*t*t*(t*(t*6.0-15.0)+10.0);
      }

      // Classic Perlin noise, periodic variant
      float pnoise(vec3 P, vec3 rep)
      {
        vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
        vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
        Pi0 = mod289(Pi0);
        Pi1 = mod289(Pi1);
        vec3 Pf0 = fract(P); // Fractional part for interpolation
        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
        vec4 iy = vec4(Pi0.yy, Pi1.yy);
        vec4 iz0 = Pi0.zzzz;
        vec4 iz1 = Pi1.zzzz;
        
        vec4 ixy = permute(permute(ix) + iy);
        vec4 ixy0 = permute(ixy + iz0);
        vec4 ixy1 = permute(ixy + iz1);
        
        vec4 gx0 = ixy0 * (1.0 / 7.0);
        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
        gx0 = fract(gx0);
        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
        vec4 sz0 = step(gz0, vec4(0.0));
        gx0 -= sz0 * (step(0.0, gx0) - 0.5);
        gy0 -= sz0 * (step(0.0, gy0) - 0.5);
        
        vec4 gx1 = ixy1 * (1.0 / 7.0);
        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
        gx1 = fract(gx1);
        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
        vec4 sz1 = step(gz1, vec4(0.0));
        gx1 -= sz1 * (step(0.0, gx1) - 0.5);
        gy1 -= sz1 * (step(0.0, gy1) - 0.5);
        
        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
        
        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
        g000 *= norm0.x;
        g010 *= norm0.y;
        g100 *= norm0.z;
        g110 *= norm0.w;
        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
        g001 *= norm1.x;
        g011 *= norm1.y;
        g101 *= norm1.z;
        g111 *= norm1.w;
        
        float n000 = dot(g000, Pf0);
        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
        float n111 = dot(g111, Pf1);
        
        vec3 fade_xyz = fade(Pf0);
        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
        return 2.2 * n_xyz;
      }

      float turbulence( vec3 p ) {
        float w = 100.0;
        float t = -.5;
        for (float f = 1.0 ; f <= 10.0 ; f++ ){
          float power = pow( 2.0, f );
          t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
        }
        return t;
      }

	     void main()	{       
      	// get a 3d noise using the position, low frequency
      	float lowFreq = pnoise( position.xyz + vec3(in_val), vec3(10.0) );
        
      	// get a turbulent 3d noise using the normal, normal to high freq
      	float highFreq = -.5 * turbulence( 0.7 * (position.xyz + vec3(in_val)) );
      
      	//add high freq noise + low freq noise together
      	//  float displacement = lowFreq;
      	//  float displacement = highFreq;
      	float displacement = (lowFreq + highFreq) * displaceAmt;

      	noiseVal = highFreq;
      	noiseVal2 = lowFreq;
      	// move the position along the normal and transform it
      	vec3 newPosition = (position.xyz + normal.xyz * displacement).xyz;
    
     		gl_Position = projectionMatrix  * viewMatrix * modelMatrix  * vec4( newPosition, 1.0 );

     		// gl_Position = projectionMatrix * viewMatrix * modelMatrix  * vec4( position, 1.0 );
      }
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			precision mediump float;
	
      varying float noiseVal;
      varying float noiseVal2;

      void main()	{
        vec3 color = vec3( 1.0 * ( 1.0 - (3.0 * noiseVal) ), 0.0, 0.0 );
        vec3 color2 = vec3( 1.0, 1.0 * ( 1.0 - (3.0 * noiseVal2) ), 0.0 );
  
        gl_FragColor = vec4( color.r, color2.gb, 1.0 );        
			}
		</script>

		<script>	
      var container;
			var camera, scene, renderer;

      // grabbing all the data from the vertex/fragment shader scripts
      var vs = document.getElementById( 'vertexShader' ).textContent;
      var fs = document.getElementById( 'fragmentShader' ).textContent;

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50.0, window.innerWidth / window.innerHeight, 0.1, 50 );
				
				//adds a default mouse listener to control the camera rotation and zoom
				var controls = new THREE.OrbitControls( camera );
				camera.position.z = 10;
				controls.update();

				scene = new THREE.Scene();

        // geometry
      	var geometry1 = new THREE.OctahedronGeometry( 4, 4 );
        var geometry2 = new THREE.TorusKnotGeometry( 1, 0.1, 100, 16 );

      	// material
      	var uniforms1 =  {
      		in_val: { type: "f", value: 0.0 },
      		displaceAmt: { type: "f", value: 0.0 }
      	};
                
      	var uniforms2 =  {
      		in_val:  { type: "f", value: 0.0 },
      		displaceAmt: { type: "f", value: 0.0 }
      	};


       	var material1 = new THREE.RawShaderMaterial( {
          uniforms: uniforms1,
          vertexShader: vs,
          fragmentShader: fs
      	} );

      	var material2 = new THREE.RawShaderMaterial( {
          uniforms: uniforms2,
          vertexShader: vs,
          fragmentShader: fs
      	} );

	      var mesh1 = new THREE.Mesh( geometry1, material1 );
	      mesh1.translateX(-1.0);
        mesh1.scale.set( 0.4, 0.4, 0.4 );
        scene.add( mesh1 );

        var mesh2 = new THREE.Mesh( geometry2, material2 );
	      mesh2.translateX(3.0);
        scene.add( mesh2 );
  
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x999999 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

        // adding gui controls
        var options = {
          velx: 0,
          vely: 0,
          camera: {
            speed: 0.0001
          },
          stop: function() {
            this.velx = 0;
            this.vely = 0;
          },
          reset: function() {
            this.velx = 0.1;
            this.vely = 0.1;
            camera.position.z = 75;
            camera.position.x = 0;
            camera.position.y = 0;
            mesh1.scale.x = 1;
            mesh1.scale.y = 1;
            mesh1.scale.z = 1;
            mesh1.material.wireframe = true;
          }
        };

        // DAT.GUI Related Stuff

        var gui = new dat.GUI();

        var cam = gui.addFolder('Camera');
        cam.add(options.camera, 'speed', 0, 0.0010).listen();
        cam.add(camera.position, 'y', 0, 100).listen();
        cam.open();

        var velocity = gui.addFolder('Velocity');
        velocity.add(options, 'velx', -0.2, 0.2).name('X').listen();
        velocity.add(options, 'vely', -0.2, 0.2).name('Y').listen();
        velocity.open();

        var box = gui.addFolder('Obj_1');
        box.add(mesh1.scale, 'x', 0, 3).name('Width').listen();
        box.add(mesh1.scale, 'y', 0, 3).name('Height').listen();
        box.add(mesh1.scale, 'z', 0, 3).name('Length').listen();
        box.add(mesh1.material, 'wireframe').listen();
        box.open();

        gui.add(options, 'stop');
        gui.add(options, 'reset');

  		}// end - function init

			function onWindowResize( event ) {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				var time = performance.now();

				var object0 = scene.children[ 0 ];
		    // object0.rotation.x = time * 0.0009;
		    // object0.rotation.y = time * 0.0005;
        // object0.material.uniforms.in_val.value += 0.01;
	 			object0.material.uniforms.displaceAmt.value = Math.sin(time * 0.001); //0.01;

        var object1 = scene.children[ 1 ];
				// object1.rotation.x = time * 0.0005;
				// object1.rotation.y = time * 0.0009;
        // object1.material.uniforms.in_val.value += 0.02;
	 			// object1.material.uniforms.displaceAmt.value = Math.sin(time * 0.001); //0.01;

				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>

