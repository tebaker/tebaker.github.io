
<!DOCTYPE html>
<html lang="en">
<head>
  <head>
    <title>Outdoor 3D Scene</title>
    <style>
      body {
        margin: 0;
        background-color: rgb(237, 215, 247);
      }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
<body>
  <h2 class="name">Talon Baker</h2>
  <div id="container"></div>

  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>

  <script id="vertexShader" type="x-shader/x-vertex">
    uniform mat4 modelMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    uniform sampler2D tPic;

    attribute vec3 position;
    attribute vec2 uv;
    attribute vec3 normal;

    uniform float displaceAmt; //controls the amount of vertex displacement...
    
    varying float vDisplace;
    varying vec2 vUv;

    precision mediump float;

    varying float noiseVal, noiseVal2;

    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
      return mod289(((x*34.0)+1.0)*x);
    }

    vec4 taylorInvSqrt(vec4 r) {
      return 1.79284291400159 - 0.85373472095314 * r;
    }

    vec3 fade(vec3 t) {
      return t*t*t*(t*(t*6.0-15.0)+10.0);
    }

    // Classic Perlin noise, periodic variant
    float pnoise( vec3 P, vec3 rep ) {
      vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
      vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
      Pi0 = mod289(Pi0);
      Pi1 = mod289(Pi1);
      vec3 Pf0 = fract(P); // Fractional part for interpolation
      vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
      vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
      vec4 iy = vec4(Pi0.yy, Pi1.yy);
      vec4 iz0 = Pi0.zzzz;
      vec4 iz1 = Pi1.zzzz;
      
      vec4 ixy = permute(permute(ix) + iy);
      vec4 ixy0 = permute(ixy + iz0);
      vec4 ixy1 = permute(ixy + iz1);
      
      vec4 gx0 = ixy0 * (1.0 / 7.0);
      vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
      gx0 = fract(gx0);
      vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
      vec4 sz0 = step(gz0, vec4(0.0));
      gx0 -= sz0 * (step(0.0, gx0) - 0.5);
      gy0 -= sz0 * (step(0.0, gy0) - 0.5);
      
      vec4 gx1 = ixy1 * (1.0 / 7.0);
      vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
      gx1 = fract(gx1);
      vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
      vec4 sz1 = step(gz1, vec4(0.0));
      gx1 -= sz1 * (step(0.0, gx1) - 0.5);
      gy1 -= sz1 * (step(0.0, gy1) - 0.5);
      
      vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
      vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
      vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
      vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
      vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
      vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
      vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
      vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
      
      vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
      g000 *= norm0.x;
      g010 *= norm0.y;
      g100 *= norm0.z;
      g110 *= norm0.w;
      vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
      g001 *= norm1.x;
      g011 *= norm1.y;
      g101 *= norm1.z;
      g111 *= norm1.w;
      
      float n000 = dot(g000, Pf0);
      float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
      float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
      float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
      float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
      float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
      float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
      float n111 = dot(g111, Pf1);
      
      vec3 fade_xyz = fade(Pf0);
      vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
      vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
      float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
      return 2.2 * n_xyz;
    }// end - pnoise()

    float turbulence( vec3 p ) {
      float w = 100.0;
      float t = -.5;
      for (float f = 1.0 ; f <= 10.0 ; f++ ){
        float power = pow( 2.0, f );
        t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
      }
      return t;
    }

    void main() {
      vUv = uv;
      
      vec4 clr = texture2D(tPic, uv);

      // clr.a is using alpha channel to determin displacement
      // vDisplace = clr.r + clr.a * displaceAmt;

      if( clr.r == 1.0 ) {
        vDisplace = clr.a * displaceAmt;
      }
      else if( clr.b == 1.0 ) {
        vDisplace = clr.a * -displaceAmt * 0.5;
      }

      vec3 newPosition = (position.xyz + normal.xyz * vDisplace).xyz;

      gl_Position = projectionMatrix  * viewMatrix * modelMatrix  * vec4( newPosition, 1.0 );
    }
  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D tGrass, tSnow, tHill;

    varying vec2 vUv;
    varying float vDisplace; 

    void main() {
      vec4 grass = texture2D(tGrass, vUv);
      vec4 snow = texture2D(tSnow, vUv);
      vec4 hill = texture2D(tHill, vUv);

      float zOffset = vDisplace;

      vec4 mix1 = mix(grass, hill, min(1.0,zOffset*8.0));
      vec4 mix2 = max(vec4(1.0), mix(hill, snow, zOffset) * 1.5);
      vec4 mix3 = mix(mix1, mix2, zOffset);


      gl_FragColor = vec4( mix3.rgb, 1.0 );
    }
  </script>

  <script>
    var container;

    var camera, scene, renderer;

    var vs = document.getElementById( 'vertexShader' ).textContent;
    var fs = document.getElementById( 'fragmentShader' ).textContent;

    var texture1 = new THREE.TextureLoader().load( 'assets/map.png' );
    var texture2 = new THREE.TextureLoader().load( 'assets/grass.png' );
    var texture3 = new THREE.TextureLoader().load( 'assets/snow.jpg' );
    var texture4 = new THREE.TextureLoader().load( 'assets/hill.jpg' );

    init();
    animate();

    function init() {
      container = document.getElementById( 'container' );

      camera = new THREE.PerspectiveCamera( 50.0, window.innerWidth / window.innerHeight, 0.1, 50 );

      //adds a default mouse listener to control the camera rotation and zoom
      var controls = new THREE.OrbitControls( camera );
      camera.position.z = 5;
      controls.update();

      scene = new THREE.Scene();

      // geometry

      var geometry1 = new THREE.PlaneGeometry( 5, 5, 300, 300 );

      // material

      var uniforms1 =  {
        displaceAmt: { type: "f", value: 0.0 },
        tPic: { type: "t", value: texture1  },
        tGrass: { type: "t", value: texture2  },
        tSnow: { type: "t", value: texture3  },
        tHill: { type: "t", value: texture4  },
      };

      var material1 = new THREE.RawShaderMaterial( {

        uniforms: uniforms1,
        vertexShader: vs,
        fragmentShader: fs,

      } );

      var mesh1 = new THREE.Mesh( geometry1, material1 );
      mesh1.material.side = THREE.DoubleSide;
      mesh1.rotateX(-Math.PI/3);
      scene.add( mesh1 );

      renderer = new THREE.WebGLRenderer();
      renderer.setClearColor( 0x999999 );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );

      window.addEventListener( 'resize', onWindowResize, false );
    }// end - init()

    function onWindowResize( event ) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
      requestAnimationFrame( animate );
      render();
    }

    function render() {
      var time = performance.now();

      var object0 = scene.children[ 0 ];
        //  object0.material.uniforms.displaceAmt.value = 0.5 * (1.0 + Math.sin(time * 0.001)); 
        
        object0.material.uniforms.displaceAmt.value = 1.0;

        renderer.render( scene, camera );
    }
  </script>
</body>
</html>

