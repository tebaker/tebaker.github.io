<html>
  <head>
    <title>3D Outdoor Scene</title>
    <style>
      body {
        margin: 0;
        background-color: rgb(237, 215, 247);
      }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <h2 class="name">Talon Baker</h2>
	
	<body>

		<div id="container"></div>

		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/dat.gui.min.js"></script>

<!-- Skybox Shaders -->
		<script id="skyboxVertexShader" type="x-shader/x-vertex">
			precision mediump float;

			uniform mat4 modelMatrix;
			uniform mat4 viewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;

			varying vec3 vWorldPosition;

			void main(){
				vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

				vec4 pos = viewMatrix * modelMatrix * vec4(position, 1.0);

				gl_Position = projectionMatrix * pos;
			}
		</script>

		<script id="skyboxFragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			
			uniform samplerCube tCube;
			varying vec3 vWorldPosition;

			void main(){
				gl_FragColor = textureCube(tCube, vWorldPosition);
			}
		</script>

<!-- Height Map Shaders -->
		<script id="heightVertexShader" type="x-shader/x-vertex">
			precision mediump float;

			uniform mat4 modelMatrix;
			uniform mat4 viewMatrix;
			uniform mat4 projectionMatrix;
			uniform sampler2D pTex;
			uniform float mixMod;

			attribute vec3 position;
			attribute vec2 uv;
			attribute vec3 normal;

			uniform float displaceAmt;

			varying vec2 vUv;
			varying float mixVal;

			void main(){
				vUv = uv;

				vec4 clr = texture2D(pTex, uv);
				float vDisplace = 0.0;

				if( clr.r > 0.0 && clr.b == 0.0 ) {
					vDisplace = clr.a * displaceAmt;
				}
				else if( clr.b > 0.0 && clr.r == 0.0 ) {
					vDisplace = -clr.a * displaceAmt;
				}

				mixVal = mix(clr.g, clr.b, 0.5) * mixMod * (displaceAmt / 5.0);

				vec3 newPos = position + normal * vDisplace;

				gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(newPos, 1.0);
			}	
		</script>

		<script id="heightFragmentShader" type="x-shader/x-fragment">
			precision mediump float;

			uniform sampler2D gTex, hTex, sTex;

			varying vec2 vUv;
			varying float mixVal;

			void main(){
				vec4 grass = texture2D(gTex, vUv);
				vec4 hill = texture2D(hTex, vUv);
				vec4 snow = texture2D(sTex, vUv);

				vec4 mix1 = mix(grass, hill, min(1.0, mixVal*8.0));
				vec4 mix2 = mix(hill, snow, mixVal);
				vec4 mix3 = mix(mix1, mix2, mixVal);

				gl_FragColor = vec4(mix3.rgb,1.0);
			}
		</script>

<!-- Water Shaders -->
		<script id="waterVertexShader" type="x-shader/x-vertex">
			
			precision mediump float;

			uniform mat4 modelMatrix, viewMatrix, projectionMatrix;
			uniform vec3 cameraPosition;
			uniform float fBias;		//
			uniform float fScale;		//
			uniform float fPower;		//
			uniform float vDisplace;
			uniform float displaceAmt;
			uniform float mixMod;		//
			uniform sampler2D pTex;		//

			uniform float waveWidth;	//
			uniform float waveHeight;	//
			uniform float time;			//

			attribute vec3 position, normal;
			attribute vec2 uv;

			varying vec3 wPosition;
			varying vec3 wNormal;
			varying vec3 vI;
			varying vec3 nI;
			varying float reflectionFactor;
			varying vec2 vUv;
			varying float mixVal;
			varying vec3 newNormal;

			vec3 mod289(vec3 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 mod289(vec4 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 permute(vec4 x) {
				return mod289(((x*34.0)+1.0)*x);
			}

			vec4 taylorInvSqrt(vec4 r) {
				return 1.79284291400159 - 0.85373472095314 * r;
			}

			vec3 fade(vec3 t) {
				return t*t*t*(t*(t*6.0-15.0)+10.0);
			}

			// Classic Perlin noise, periodic variant
			float pnoise(vec3 P, vec3 rep) {
				vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
				vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
				Pi0 = mod289(Pi0);
				Pi1 = mod289(Pi1);
				vec3 Pf0 = fract(P); // Fractional part for interpolation
				vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				vec4 iy = vec4(Pi0.yy, Pi1.yy);
				vec4 iz0 = Pi0.zzzz;
				vec4 iz1 = Pi1.zzzz;

				vec4 ixy = permute(permute(ix) + iy);
				vec4 ixy0 = permute(ixy + iz0);
				vec4 ixy1 = permute(ixy + iz1);

				vec4 gx0 = ixy0 * (1.0 / 7.0);
				vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				gx0 = fract(gx0);
				vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				vec4 sz0 = step(gz0, vec4(0.0));
				gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				vec4 gx1 = ixy1 * (1.0 / 7.0);
				vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				gx1 = fract(gx1);
				vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				vec4 sz1 = step(gz1, vec4(0.0));
				gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				g000 *= norm0.x;
				g010 *= norm0.y;
				g100 *= norm0.z;
				g110 *= norm0.w;
				vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				g001 *= norm1.x;
				g011 *= norm1.y;
				g101 *= norm1.z;
				g111 *= norm1.w;

				float n000 = dot(g000, Pf0);
				float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				float n111 = dot(g111, Pf1);

				vec3 fade_xyz = fade(Pf0);
				vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
				return 2.2 * n_xyz;
			}

			float turbulence( vec3 p ) {
				float w = 100.0;
				float t = -.5;
				for (float f = 1.0 ; f <= 10.0 ; f++ ){
					float power = pow( 2.0, f );
					t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
				}
				return t;
			}

			void main(){

				float lowFreq = pnoise( position.xyz + vec3(time), vec3(10.0) );
				float highFreq = -.5 * turbulence( 0.7 * (position.xyz + vec3(time)) );
				
				float zDisplacement = (lowFreq + highFreq) * waveHeight;

				float rI = 0.01;

				wNormal = normalize(mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz)*normal);
				
				newNormal = normalize(vec3(wNormal.x + zDisplacement*rI, wNormal.y, wNormal.z + zDisplacement*rI));

				wPosition = (modelMatrix * vec4(position, 1.0)).xyz;

				vI = wPosition - cameraPosition;
				
				vUv = uv;

				vec4 clr = texture2D(pTex, vec2(vUv.x, vUv.y));
				float vDisplace = mix(clr.g, clr.b, 0.5) * displaceAmt;
				mixVal = mix(clr.g, clr.b, 0.5) * mixMod * (displaceAmt / 5.0);

				reflectionFactor = fBias + fScale * pow(1.0 + dot(normalize(vI), wNormal), fPower);

				wPosition = vec3(wPosition.x, zDisplacement, wPosition.z);

				gl_Position = projectionMatrix * viewMatrix * vec4(wPosition, 1.0);
			}

		</script>

		<script id="waterFragmentShader" type="x-shader/x-fragment">
			
			precision mediump float;

			uniform samplerCube tCube;
			uniform sampler2D gTex, hTex, sTex;


			varying vec3 wPosition;
			varying vec3 wNormal;
			varying vec3 newNormal;
			varying vec3 vI;
			varying vec3 nI;
			varying float reflectionFactor;
			varying vec2 vUv;
			varying float mixVal;

			void main(){

				vec4 grass = texture2D(gTex, vUv);
				vec4 hill = texture2D(hTex, vUv);
				vec4 snow = texture2D(sTex, vUv);

				vec4 mix1 = mix(grass, hill, min(1.0, mixVal*8.0));
				vec4 mix2 = mix(hill, snow, mixVal);
				vec4 mix3 = mix(mix1, mix2, mixVal);

				vec3 reflection = reflect(vI, newNormal);

				vec4 envColor = textureCube(tCube, vec3(reflection.x, reflection.yz));

				gl_FragColor = vec4(mix(mix3.xyz, envColor.xyz, vec3(clamp(reflectionFactor, 0.0, 1.0))), 1.0);
			}

		</script>

		<script>

			var container, camera, renderer, scene, controls;

			var skyboxVS, skyboxFS;
			var heightVS, heightFS;
			var waterVS,  waterFS;

			var skyboxMesh, waterMesh, heightMesh;

			var cubeMap;

			var heightTex = new THREE.TextureLoader().load('assets/map.png');
			var grassTex = new THREE.TextureLoader().load('assets/grass.png');
			var hillTex = new THREE.TextureLoader().load('assets/hill.jpg');
			var snowTex = new THREE.TextureLoader().load('assets/snow.jpg');

			var heightUniforms;

			var gui = new dat.GUI({width: 250});

			guiOptions = {};

			init();
			render();

			function init(){

				container = document.getElementById('container');
				skyboxVS = document.getElementById('skyboxVertexShader').textContent;
				skyboxFS = document.getElementById('skyboxFragmentShader').textContent;
				heightVS = document.getElementById('heightVertexShader').textContent;
				heightFS = document.getElementById('heightFragmentShader').textContent;
				waterVS = document.getElementById('waterVertexShader').textContent;
				waterFS = document.getElementById('waterFragmentShader').textContent;

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
				camera.position.set(0, 50,-130);

				controls = new THREE.OrbitControls(camera);

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);

				// adding cube map to scene
				cubeMap = new THREE.CubeTextureLoader().load([
			        'assets/skyboxes/interstellarPosX.png',
			        'assets/skyboxes/interstellarNegX.png',
			        'assets/skyboxes/interstellarPosY.png',
			        'assets/skyboxes/interstellarNegY.png',
			        'assets/skyboxes/interstellarPosZ.png',
			        'assets/skyboxes/interstellarNegZ.png',
			    ]);

				skyMat = new THREE.RawShaderMaterial({
					uniforms: { "tCube": {type: "t", value: cubeMap} },
					vertexShader: skyboxVS,
					fragmentShader: skyboxFS
				});

				skyMat.depthWrite = false;
				skyMat.side = THREE.BackSide;

				var skyGeo = new THREE.BoxGeometry(2000, 2000, 2000);

				skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
				scene.add(skyboxMesh);
				
				// defining all the gui guiOptions variables
				guiOptions.displaceAmt = 17.0;
				guiOptions.mixMod = 0.2;
				guiOptions.waterLevel = 5;
				guiOptions.fresnelBias = 0.5;
				guiOptions.fresnelScale = 2;
				guiOptions.fresnelPower = 2;
				guiOptions.waveW = 0.5;
				guiOptions.waveH = 0.5;

				guiOptions.inVal = 0.0;
				guiOptions.displamentAmount = 0.0;

				gui.add(guiOptions, "displaceAmt", 0, 50);
				gui.add(guiOptions, "mixMod", 0, 1);
				gui.add(guiOptions, "waterLevel", -10, 40);
				gui.add(guiOptions, "waveW", 0, 20);
				gui.add(guiOptions, "waveH", -10, 10);


				// adding water to the scene
				var waterGeo = new THREE.PlaneBufferGeometry(100, 100, 300, 300);

				waterUniforms = {
					displaceAmt: {type: "f", value: 17.0},
					mixMod: {type: "f", value: 0.2},
					tCube: {type: "t", value: cubeMap},
					fBias: {type: "f", value: 0.5},
					fScale: {type: "f", value: 0.5},
					fPower: {type: "f", value: 2.0},
					pTex: {type: "t", value: heightTex},
					gTex: {type: "t", value: grassTex},
					hTex: {type: "t", value: hillTex},
					sTex: {type: "t", value: snowTex},
					waveWidth: {type: "f", value: 0.5},
					waveHeight: {type: "f", value: 0.5},
					time: {type: "f", value: 1.0},
					inVal: {type: "f", value: 0.1},
					displamentAmount: {type: "f", value: 0.0}
				}

				var waterMat = new THREE.RawShaderMaterial({
					uniforms: waterUniforms,
					vertexShader: waterVS,
					fragmentShader: waterFS
				})

				waterMesh = new THREE.Mesh(waterGeo, waterMat);
				waterMesh.material.side = THREE.DoubleSide;
				waterMesh.rotateX(-Math.PI/2);
				waterMesh.rotateZ(-Math.PI*2/3);
				scene.add(waterMesh);

				//adding height map to the scene
				var heightGeo = new THREE.PlaneGeometry(100, 100, 500, 500);

				heightUniforms = {
					displaceAmt: {type: "f", value: guiOptions.displaceAmt},
					mixMod: {type: "f", value: guiOptions.mixMod},
					pTex: {type: "t", value: heightTex},
					gTex: {type: "t", value: grassTex},
					hTex: {type: "t", value: hillTex},
					sTex: {type: "t", value: snowTex}
				}

				var heightMat = new THREE.RawShaderMaterial({
					uniforms: heightUniforms,
					vertexShader: heightVS,
					fragmentShader: heightFS
				})

				heightMesh = new THREE.Mesh(heightGeo, heightMat);
				heightMesh.material.side = THREE.DoubleSide;
				heightMesh.rotateX(-Math.PI/2);
				heightMesh.rotateZ(-Math.PI*2/3);
				heightMesh.position.y = 1.0;
				scene.add(heightMesh);


				//adding ojects to the scene
				// var loader = new THREE.OBJLoader();
							
				// loader.load( 'assets/carrot.obj', function ( object ) {
					
				// 	object.traverse( function ( child ) {
				// 		if ( child instanceof THREE.Mesh ) {
				// 			child.material = material2;
				// 		}
				// 	} );
					
				// 	var s = 2.0;
				// 	object.scale.set( s, s, s );
				// 	object.position.x += 1.0;
				// 	object.position.y -= 0.5;

				// 	carrot = object;
				// 	scene.add( carrot );
				// } );

				// loader.load( 'assets/bunny.obj', function ( object ) {
					
				// 	object.traverse( function ( child ) {
				// 		if ( child instanceof THREE.Mesh ) {
				// 			child.material = material2;
				// 		}
				// 	} );
					
				// 	var s = 2.0;
				// 	object.scale.set( s, s, s );
				// 	object.position.x += 1.0;
				// 	object.position.y -= 0.5;

				// 	bunny = object;
				// 	scene.add( bunny );
				// } );

				container.appendChild(renderer.domElement);
				window.addEventListener('resize', onWindowResize, false);

			}

			function onWindowResize(){

				renderer.setSize(window.innerWidth, window.innerHeight);

				camera.aspect = window.innerWidth/window.innerHeight;
				camera.updateProjectionMatrix();
			}

			function updateUniforms(){

				var time = performance.now();

				waterUniforms.displaceAmt = {type: "f", value: guiOptions.displaceAmt};
				waterUniforms.mixMod = {type: "f", value: guiOptions.mixMod};

				waterUniforms.fBias = {type: "f", value: guiOptions.fresnelBias};
				waterUniforms.fScale = {type: "f", value: guiOptions.fresnelScale};
				waterUniforms.fPower = {type: "f", value: guiOptions.fresnelPower};
				waterUniforms.waveWidth = {type: "f", value: guiOptions.waveW};
				waterUniforms.waveHeight = {type: "f", value: guiOptions.waveH};
				waterUniforms.time.value = time * 0.001;

			}

			function render(){

				requestAnimationFrame(render);

				updateUniforms();
				renderer.render(scene, camera);

			}


		</script>


	</body>
</html>